     1                                  ;kernel.asm
     2                                  ;
     3                                  ;内核程序
     4                                  ;
     5                                  ;主要做的事：
     6                                  ;   1. 提供若干可供用户程序调用的例程
     7                                  ;   2. 加载及重定位用户程序并执行用户程序
     8                                  ;   3. 执行完用户程序后控制权回到内核
     9                                  ;
    10                                  ;要点技巧：
    11                                  ;   1. salt
    12                                  ;
    13                                  
    14                                  video_ram_seg_sel       equ 0x10    ;显存段选择子
    15                                  mem_0_4_gb_seg_sel      equ 0x08    ;0-4G内存数据段选择子
    16                                  kernel_data_seg_sel     equ 0x30    ;内核数据段选择子
    17                                  kernel_code_seg_sel     equ 0x38    ;内核代码段选择子
    18                                  kernel_stack_seg_sel    equ 0x20    ;内核栈段选择子
    19                                  kernel_sysroute_seg_sel equ 0x28    ;内核系统例程段选择子
    20                                  
    21                                  user1_prog_start_sector  equ 40      ;用户程序起始逻辑扇区号
    22                                  user2_prog_start_sector  equ 50      ;用户程序起始逻辑扇区号
    23                                  
    24 00000000 [00000000]              kernel_len      dd  kernel_end
    25 00000004 [00000000]              kenerl_section  dd  section.sys_routine.start 
    26 00000008 [00000000]                              dd  section.kernel_data.start
    27 0000000C [00000000]                              dd  section.kernel_code.start
    28 00000010 [B3030000]              kernel_entry    dd  start
    29 00000014 3800                                    dw  kernel_code_seg_sel
    30                                  
    31                                  [bits 32]
    32                                  ;系统例程段;{{{
    33                                  SECTION sys_routine vstart=0
    34                                  
    35                                  ;putstr函数;{{{
    36                                  ;功能：
    37                                  ;   打印一个字符串，以0为结束符
    38                                  ;参数：
    39                                  ;   ds:ebx = 要打印的字符串地址
    40                                  ;输出：
    41                                  ;   无
    42                                  putstr:
    43 00000000 60                          pushad
    44                                  
    45                                  .nextchar:
    46 00000001 8A0B                        mov cl,[ebx]
    47 00000003 80F900                      cmp cl,0
    48 00000006 7408                        jz .exit
    49 00000008 E805000000                  call putchar
    50 0000000D 43                          inc ebx
    51 0000000E EBF1                        jmp .nextchar
    52                                  
    53                                  .exit:
    54 00000010 61                          popad
    55 00000011 CB                          retf
    56                                  ;}}}
    57                                  ;putchar函数;{{{
    58                                  ;
    59                                  ;功能：
    60                                  ;   打印单个字符
    61                                  ;参数： 
    62                                  ;   cl = 要打印的字符
    63                                  ;输出：
    64                                  ;   无
    65                                  putchar:
    66 00000012 60                          pushad
    67                                  
    68                                      ;获取当前光标位置
    69                                      ;光标位置是一个16位的数值，需要分别获取其高8位与低8位
    70                                      ;获取光标位置的高8位
    71                                      ;   向显卡的索引寄存器0x3d4端口写入0x0e，从索引寄存器的0x3d5端口读8位数据，
    72                                      ;获取光标位置的低8位
    73                                      ;   向显卡的索引寄存器0x3d4端口写入0x0f，从索引寄存器的0x3d5端口读8位数据，
    74 00000013 66BAD403                    mov dx,0x3d4
    75 00000017 B00E                        mov al,0x0e
    76 00000019 EE                          out dx,al
    77 0000001A 66BAD503                    mov dx,0x3d5
    78 0000001E EC                          in  al,dx
    79 0000001F 88C4                        mov ah,al
    80                                  
    81 00000021 66BAD403                    mov dx,0x3d4
    82 00000025 B00F                        mov al,0x0f
    83 00000027 EE                          out dx,al
    84 00000028 66BAD503                    mov dx,0x3d5
    85 0000002C EC                          in  al,dx       ;当前光标位置已保存到ax中
    86 0000002D 6689C3                      mov bx,ax       ;ax将用于接下来的div运算
    87                                  
    88                                      ;打印字符cl，要特殊处理\r:0x0d,\n:0x0a
    89                                  
    90                                      ;处理\r（0x0d，回车，将光标位置移到当前行第一列）
    91                                      ;处理：
    92                                      ;   将光标位置 / 80 得到当前光标行号（每行80列）
    93                                      ;   当前光标行 * 80 为当前行首列位置，将该位置设为当前光标位置
    94 00000030 80F90D                      cmp cl,0x0d
    95 00000033 7511                        jnz .line_feed
    96 00000035 6631D2                      xor dx,dx
    97 00000038 B350                        mov bl,80
    98 0000003A F6F3                        div bl          ;div r/m16   dx:ax / r/m16 => ax ... dx
    99 0000003C F6E3                        mul bl          ;mul r/m16   ax * r/m16 => dx:ax
   100 0000003E 6689C3                      mov bx,ax
   101 00000041 E92C000000                  jmp .roll_screen
   102                                  
   103                                      ;处理\n（0x0a，换行，将光标位置移到当前列下一行）
   104                                      ;处理：
   105                                      ;   将光标位置 + 80 （每行80列）
   106                                  .line_feed:
   107 00000046 80F90A                      cmp cl,0x0a
   108 00000049 750A                        jnz .normal_char
   109 0000004B 6681C35000                  add bx,80
   110 00000050 E91D000000                  jmp .roll_screen
   111                                  
   112                                      ;打印普通字符并将光标移向下一个位置
   113                                      ;将光标位置*2得到当前光标的显存地址，往该地址写字符即可显示
   114                                      ;每个字符占两个字节，第一个字节用于存储字符ascii码，第二个字节用于控制字符属性
   115                                      ;|--------------------------------|
   116                                      ;|15               7 6 5 4 3 2 1 0|
   117                                      ;|--------------------------------|
   118                                      ;|    ascii 15:8   k r g b i r g b|
   119                                      ;                  \     / \     /
   120                                      ;                     bg      fg
   121                                      ;
   122                                      ; k : 0 - blink, 1 - no-blink
   123                                  
   124                                  .normal_char:
   125 00000055 06                          push es
   126 00000056 66B81000                    mov ax,video_ram_seg_sel    ;显存段 
   127 0000005A 8EC0                        mov es,ax
   128 0000005C 66D1E3                      shl bx,1
   129 0000005F 2667880F                    mov [es:bx],cl
   130 00000063 2667C6470102                mov byte [es:bx+1],00000010B    ;00000010B - 黑底绿字
   131 00000069 66D1EB                      shr bx,1
   132 0000006C 07                          pop es
   133                                  
   134 0000006D 6681C30100                  add bx,1        ;光标推后一个位置
   135                                  
   136                                      ;滚屏，每行字符往上移一行并清空最后一行
   137                                  .roll_screen:
   138 00000072 6681FBD007                  cmp bx,2000     ;80*25=2000, 表示光标超出屏幕，需要滚屏
   139 00000077 7C35                        jl  .set_cursor
   140                                  
   141 00000079 1E                          push ds
   142 0000007A 06                          push es
   143                                  
   144 0000007B 66B81000                    mov ax,video_ram_seg_sel    ;显存段
   145 0000007F 8ED8                        mov ds,ax
   146 00000081 8EC0                        mov es,ax
   147 00000083 FC                          cld
   148 00000084 BF00000000                  mov edi,0
   149 00000089 BEA0000000                  mov esi,160     ;一行80个字符*2字节每字符
   150 0000008E B980070000                  mov ecx,1920    ;2000-80
   151 00000093 F366A5                      rep movsw       ;每行字符往上移一行
   152                                  
   153                                      ;以黑底白字的空格符填充最后一行
   154 00000096 66B95000                    mov cx,80
   155                                  .clr_char:
   156 0000009A 2666C7072007                mov word [es:edi],0x0720
   157 000000A0 81C702000000                add edi,2
   158 000000A6 E2F2                        loop .clr_char
   159                                  
   160 000000A8 66BB8007                    mov bx,1920
   161 000000AC 07                          pop es
   162 000000AD 1F                          pop ds
   163                                  
   164                                      ;设置bx为下一光标位置
   165                                  .set_cursor:
   166 000000AE 66BAD403                    mov dx,0x3d4
   167 000000B2 B00E                        mov al,0x0e
   168 000000B4 EE                          out dx,al
   169 000000B5 66BAD503                    mov dx,0x3d5
   170 000000B9 88F8                        mov al,bh
   171 000000BB EE                          out dx,al
   172                                  
   173 000000BC 66BAD403                    mov dx,0x3d4
   174 000000C0 B00F                        mov al,0x0f
   175 000000C2 EE                          out dx,al
   176 000000C3 66BAD503                    mov dx,0x3d5
   177 000000C7 88D8                        mov al,bl
   178 000000C9 EE                          out dx,al
   179                                  
   180 000000CA 61                          popad
   181 000000CB C3                          ret
   182                                  ;}}}
   183                                  ;read_one_disk_sector函数;{{{
   184                                  ;
   185                                  ;功能：
   186                                  ;   从硬盘读取一个扇区（512字节）
   187                                  ;参数：
   188                                  ;   eax = 逻辑扇区号
   189                                  ;   ds:ebx = 目标缓冲区地址
   190                                  ;输出：
   191                                  ;   ebx += 512
   192                                  
   193                                  ;如果读写硬盘;{{{
   194                                  ;硬盘的读写单位是一个扇区
   195                                  ;主硬盘控制器被分配到了八个端口：0x1f0 - 0x0f7
   196                                  ;用LBA28方式读写硬盘:
   197                                  ;   1. 往0x1f2端口(8bit)写入要读取的扇区数目
   198                                  ;   2. 将28位起始LBA扇区号写入0x1f3,0x1f4,0x1f5,0x1f6端口(均为8big)
   199                                  ;           ---------------------------------------------------------------------    
   200                                  ;           31 30 29 28 27      23              16              7               0
   201                                  ;           ---------------------------------------------------------------------    
   202                                  ;           |       0x1f6       |     0x1f5     |     0x1f4     |     0x1f3     | 
   203                                  ;           ---------------------------------------------------------------------    
   204                                  ;            1  |  1 |   \                                                     /
   205                                  ;               |    |    `````````````````````````````````````````````````````
   206                                  ;               |    |                           LBA28
   207                                  ;       0: CHS _|    |_ 0: 主硬盘(master)
   208                                  ;       1: LBA          1: 从硬盘(slave)
   209                                  ;   3. 往0x1f7端口(8bit)写入0x20，请求硬盘读
   210                                  ;   4. 等待硬盘准备好读写, 0x1f7既是命令端口也是状态端口，此时为状态端口，含义如下：
   211                                  ;       -----------------------------
   212                                  ;       7   6   5   4   3   2   1   0
   213                                  ;       -----------------------------
   214                                  ;       |               |           |           
   215                                  ;       |_ 0: 硬盘闲    |           |_ 0: 前一个命令执行成功
   216                                  ;          1: 硬盘忙    |              1: 前一个命令执行失败，具体原因查看0x1f1
   217                                  ;                       |_ 0: 硬盘未准备好与主机交换数据
   218                                  ;                          1: 硬盘已准备好与主机交换数据
   219                                  ;       当bit7为0且bit3为1时，表示可以进行读硬盘了
   220                                  ;   5. 从0x1f0端口(16bit)读取数据
   221                                  ;}}}
   222                                  read_one_disk_sector:
   223 000000CC 50                          push eax
   224 000000CD 51                          push ecx
   225 000000CE 6652                        push dx
   226                                      
   227 000000D0 89C1                        mov ecx,eax
   228                                  
   229 000000D2 66BAF201                    mov dx,0x1f2    ;1. 读取1个扇区
   230 000000D6 B001                        mov al,1
   231 000000D8 EE                          out dx,al
   232                                  
   233 000000D9 6642                        inc dx          ;2.1 0x1f3 <= eax 7:0
   234 000000DB 89C8                        mov eax,ecx
   235 000000DD EE                          out dx,al
   236                                  
   237 000000DE 6642                        inc dx          ;2.2 0x1f4 <= eax 15:8
   238 000000E0 C1E808                      shr eax,8
   239 000000E3 EE                          out dx,al
   240                                  
   241 000000E4 6642                        inc dx          ;2.3 0x1f5 <= eax 23:16
   242 000000E6 C1E808                      shr eax,8
   243 000000E9 EE                          out dx,al
   244                                  
   245 000000EA 6642                        inc dx          ;2.4 0x1f6 <= eax 27:24
   246 000000EC C1E808                      shr eax,8
   247 000000EF 240F                        and al,0x0f
   248 000000F1 0CE0                        or  al,0xe0     ;主硬盘+LBA方式
   249 000000F3 EE                          out dx,al
   250                                  
   251 000000F4 6642                        inc dx          ;3. 发送硬盘读命令
   252 000000F6 B020                        mov al,0x20 
   253 000000F8 EE                          out dx,al
   254                                  
   255                                  .wait:              ;4. 等待硬盘准备好可读
   256 000000F9 EC                          in  al,dx
   257 000000FA 2488                        and al,0x88
   258 000000FC 3C08                        cmp al,0x08
   259 000000FE 75F9                        jnz .wait
   260                                      
   261 00000100 B900010000                  mov ecx,256     ;5. 读取硬盘
   262 00000105 66BAF001                    mov dx,0x1f0
   263                                  .rw:
   264 00000109 66ED                        in  ax,dx 
   265 0000010B 668903                      mov [ebx],ax
   266 0000010E 81C302000000                add ebx,2
   267 00000114 E2F3                        loop .rw
   268                                  
   269 00000116 665A                        pop dx
   270 00000118 59                          pop ecx
   271 00000119 58                          pop eax
   272                                  
   273 0000011A CB                          retf
   274                                  ;}}}
   275                                  ;make_seg_descriptor函数;{{{
   276                                  ;
   277                                  ;功能：
   278                                  ;   构造段描述符
   279                                  ;参数：
   280                                  ;   eax = 段线性基地址（32位）
   281                                  ;   ebx = 段界限（20位）
   282                                  ;   ecx = 属性（各属性位都在原始位置，没用到的位为0）
   283                                  ;输出：
   284                                  ;   edx:eax 完整的段描述符
   285                                  make_seg_descriptor:
   286 0000011B 89C2                        mov edx,eax
   287 0000011D C1C010                      rol eax,16      ;Set Base 15:0
   288 00000120 6689D8                      mov ax,bx       ;Set Limit 15:0
   289                                  
   290 00000123 81E20000FFFF                and edx,0xffff0000
   291 00000129 C1C208                      rol edx,8
   292 0000012C 0FCA                        bswap edx       ;Set Base 31:24 and Base 23:16
   293                                  
   294 0000012E 81E300000F00                and ebx,0x000f0000
   295 00000134 09DA                        or  edx,ebx     ;Set Limit 19:16
   296                                  
   297 00000136 09CA                        or  edx,ecx     ;Set Prop.
   298                                  
   299 00000138 CB                          retf
   300                                  ;}}}
   301                                  ;make_call_gate_descriptor函数;{{{
   302                                  ;
   303                                  ;功能：
   304                                  ;   构造段描述符
   305                                  ;参数：
   306                                  ;   ax  = 目标代码段选择子
   307                                  ;   ebx = 段内偏移值
   308                                  ;   cx  = 属性（各属性位都在原始位置，没用到的位为0）
   309                                  ;输出：
   310                                  ;   edx:eax 完整的段描述符
   311                                  make_call_gate_descriptor:
   312 00000139 53                          push ebx
   313 0000013A 51                          push ecx
   314                                  
   315 0000013B C1E010                      shl eax,16          ;设置段选择子
   316 0000013E 6689D8                      mov ax,bx           ;设置段偏移15:0
   317 00000141 66BB0000                    mov bx,0
   318 00000145 21DA                        and edx,ebx         ;设置段偏移31:16
   319 00000147 6689CA                      mov dx,cx           ;设置属性
   320                                  
   321 0000014A 59                          pop ecx
   322 0000014B 5B                          pop ebx
   323 0000014C CB                          retf
   324                                  ;}}}
   325                                  ;install_gdt_descriptor函数;{{{
   326                                  ;
   327                                  ;功能：
   328                                  ;   安装段描述符到GDT并返回段选择子
   329                                  ;参数：
   330                                  ;   edx:eax = 完整的段描述符
   331                                  ;输出：
   332                                  ;   cx = 段选择子
   333                                  install_gdt_descriptor:
   334 0000014D 53                          push ebx
   335 0000014E 1E                          push ds
   336 0000014F 06                          push es
   337                                  
   338 00000150 BB30000000                  mov ebx,kernel_data_seg_sel
   339 00000155 8EDB                        mov ds,ebx
   340                                  
   341 00000157 BB08000000                  mov ebx,mem_0_4_gb_seg_sel
   342 0000015C 8EC3                        mov es,ebx
   343                                  
   344 0000015E 0F0105[00000000]            sgdt [pgdt]
   345                                  
   346                                      ;写入段描述符
   347 00000165 51                          push ecx
   348 00000166 0FB70D[00000000]            movzx ecx,word [pgdt]       
   349 0000016D 6641                        inc cx
   350 0000016F 030D[02000000]              add ecx,[pgdt+0x02]
   351 00000175 268901                      mov [es:ecx],eax
   352 00000178 26895104                    mov [es:ecx+0x04],edx
   353 0000017C 59                          pop ecx
   354                                  
   355                                      ;更新GDT界限
   356 0000017D 668105[00000000]08-         add word [pgdt],8           
   357 00000185 00                 
   358 00000186 0F0115[00000000]            lgdt [pgdt]
   359                                  
   360                                      ;构造段选择子
   361 0000018D 6652                        push dx
   362 0000018F 6650                        push ax
   363 00000191 66A1[00000000]              mov ax,[pgdt]               
   364 00000197 6631D2                      xor dx,dx
   365 0000019A 66B90800                    mov cx,8
   366 0000019E 66F7F1                      div cx
   367 000001A1 6689C1                      mov cx,ax
   368 000001A4 66C1E103                    shl cx,3                    ;左移三位将索引移到正确位置
   369                                                                  ;同时腾出了TI,RPL三位(填充0)
   370 000001A8 6658                        pop ax
   371 000001AA 665A                        pop dx
   372                                  
   373 000001AC 07                          pop es
   374 000001AD 1F                          pop ds
   375 000001AE 5B                          pop ebx
   376                                  
   377 000001AF CB                          retf
   378                                  ;}}}
   379                                  ;allocate_memory函数;{{{
   380                                  ;
   381                                  ;功能：
   382                                  ;   分配指定大小的内存区域
   383                                  ;参数：
   384                                  ;   ecx = 希望分配的字节数
   385                                  ;输出：
   386                                  ;   ecx = 分配的内存起始线性地址
   387                                  allocate_memory:
   388 000001B0 50                          push eax
   389 000001B1 53                          push ebx
   390 000001B2 1E                          push ds
   391                                  
   392 000001B3 B830000000                  mov eax,kernel_data_seg_sel
   393 000001B8 8ED8                        mov ds,eax
   394                                  
   395 000001BA A1[06000000]                mov eax,[memory]
   396 000001BF 01C8                        add eax,ecx         ;让下一个地址4字节对齐
   397 000001C1 89C3                        mov ebx,eax
   398 000001C3 81E3FCFFFFFF                and ebx,0xfffffffc
   399 000001C9 81C304000000                add ebx,4
   400 000001CF A903000000                  test eax,0x3
   401 000001D4 0F45C3                      cmovnz eax,ebx
   402                                  
   403 000001D7 8B0D[06000000]              mov ecx,[memory]
   404                                  
   405 000001DD A3[06000000]                mov [memory],eax
   406                                  
   407 000001E2 1F                          pop ds
   408 000001E3 5B                          pop ebx
   409 000001E4 58                          pop eax
   410                                  
   411 000001E5 CB                          retf
   412                                  ;}}}
   413                                  ;put_hex_dword函数;{{{
   414                                  ;
   415                                  ;功能：
   416                                  ;   在当前光标位置以字符形式（0xABCD）打印一个双字，并推进光标位置
   417                                  ;参数：
   418                                  ;   edx = 要打印的双字
   419                                  ;输出：
   420                                  ;   无
   421                                  put_hex_dword:
   422 000001E6 50                          push eax
   423 000001E7 53                          push ebx
   424 000001E8 51                          push ecx
   425 000001E9 52                          push edx
   426 000001EA 1E                          push ds
   427                                      
   428 000001EB B830000000                  mov eax,kernel_data_seg_sel
   429 000001F0 8ED8                        mov ds,eax
   430                                  
   431 000001F2 B130                        mov cl,'0'
   432 000001F4 E819FEFFFF                  call putchar
   433 000001F9 B178                        mov cl,'x'
   434 000001FB E812FEFFFF                  call putchar
   435                                  
   436 00000200 B908000000                  mov ecx,8
   437 00000205 BB[0A000000]                mov ebx,hex_table
   438                                  .print_4bits:
   439 0000020A C1C204                      rol edx,4
   440 0000020D 88D0                        mov al,dl
   441 0000020F 240F                        and al,0xf
   442 00000211 D7                          xlatb
   443 00000212 6651                        push cx
   444 00000214 88C1                        mov cl,al
   445 00000216 E8F7FDFFFF                  call putchar
   446 0000021B 6659                        pop cx
   447 0000021D E2EB                        loop .print_4bits
   448                                  
   449 0000021F 1F                          pop ds
   450 00000220 5A                          pop edx
   451 00000221 59                          pop ecx
   452 00000222 5B                          pop ebx
   453 00000223 58                          pop eax
   454                                  
   455 00000224 CB                          retf
   456                                  ;}}}
   457                                  
   458                                  sys_routine_end:
   459                                  ;}}}
   460                                  
   461                                  ;内核数据段;{{{
   462                                  SECTION kernel_data vstart=0
   463                                  
   464                                  ;install_gdt_descriptor函數需要內存临时保存GDT
   465 00000000 0000                    pgdt    dw  0
   466 00000002 00000000                        dd  0
   467                                  ;allocate_memory函数用来存储下一个分配地址
   468 00000006 00001000                memory  dd  0x00100000
   469                                  ;put_hex_dword函数用的十六进制表
   470 0000000A 303132333435363738-     hex_table   db  '0123456789abcdef'
   471 00000013 39616263646566     
   472                                  
   473 0000001A 0A0D00                  return_str  db 0x0a, 0x0d, 0
   474                                  
   475 0000001D 4E6F7720697320696E-     msg_1       db 'Now is in kernel, prepare to load user program', 0x0a, 0x0d, 0
   476 00000026 206B65726E656C2C20-
   477 0000002F 707265706172652074-
   478 00000038 6F206C6F6164207573-
   479 00000041 65722070726F677261-
   480 0000004A 6D0A0D00           
   481 0000004E 43505520494E464F3A-     cpu_brnd0   db 'CPU INFO: ', 0
   482 00000057 2000               
   483 00000059 00<rept>                cpu_brand   times   64  db 0
   484 00000099 557365722050726F67-     msg_3       db 'User Program Loaded.', 0
   485 000000A2 72616D204C6F616465-
   486 000000AB 642E00             
   487 000000AE 4261636B2066726F6D-     msg_2       db 'Back from user program', 0
   488 000000B7 20757365722070726F-
   489 000000C0 6772616D00         
   490                                  
   491 000000C5 0A0D4261636B206672-     return_msg1 db 0x0a, 0x0d, 'Back from user program 1, re-enter...', 0x0a, 0x0d, 0
   492 000000CE 6F6D20757365722070-
   493 000000D7 726F6772616D20312C-
   494 000000E0 2072652D656E746572-
   495 000000E9 2E2E2E0A0D00       
   496 000000EF 0A0D4261636B206672-     return_msg2 db 0x0a, 0x0d, 'Back from user program 2, re-enter...', 0x0a, 0x0d, 0
   497 000000F8 6F6D20757365722070-
   498 00000101 726F6772616D20322C-
   499 0000010A 2072652D656E746572-
   500 00000113 2E2E2E0A0D00       
   501                                  
   502 00000119 0A0D726563616C6C20-     msg_4       db 0x0a, 0x0d, 'recall user program', 0x0a, 0x0d, 0
   503 00000122 757365722070726F67-
   504 0000012B 72616D0A0D00       
   505                                  
   506 00000131 0A0D66726F6D206361-     terminate_msg1  db 0x0a, 0x0d, 'from call or exception', 0x0a, 0x0d, 0
   507 0000013A 6C6C206F7220657863-
   508 00000143 657074696F6E0A0D00 
   509 0000014C 0A0D66726F6D206A6D-     terminate_msg2  db 0x0a, 0x0d, 'from jmp', 0x0a, 0x0d, 0
   510 00000155 700A0D00           
   511                                  
   512 00000159 0A0D4B65726E656C20-     hlt_msg     db 0x0a, 0x0d, 'Kernel has nothing to do, hlt.', 0
   513 00000162 686173206E6F746869-
   514 0000016B 6E6720746F20646F2C-
   515 00000174 20686C742E00       
   516                                  
   517 0000017A 00000000                tcb_chain   dd 0
   518                                  
   519 0000017E 00<rept>                user_header_buffer  times 512 db 0
   520                                  
   521                                  ;salt表{{{
   522                                  salt:
   523                                  
   524 0000037E 405072696E74537472-     salt_1      db '@PrintString'
   525 00000387 696E67             
   526 0000038A 00<rept>                            times (256-($-salt_1))  db 0
   527 0000047E [00000000]                          dd putstr
   528 00000482 2800                                dw kernel_sysroute_seg_sel
   529                                  
   530 00000484 40526561644469736B-     salt_2      db '@ReadDiskData'
   531 0000048D 44617461           
   532 00000491 00<rept>                            times (256-($-salt_2))  db 0
   533 00000584 [CC000000]                          dd read_one_disk_sector
   534 00000588 2800                                dw kernel_sysroute_seg_sel
   535                                  
   536 0000058A 405072696E7444776F-     salt_3      db '@PrintDwordAsHexString'
   537 00000593 726441734865785374-
   538 0000059C 72696E67           
   539 000005A0 00<rept>                            times (256-($-salt_3))  db 0
   540 0000068A [E6010000]                          dd put_hex_dword
   541 0000068E 2800                                dw kernel_sysroute_seg_sel
   542                                  
   543 00000690 4052656C6561736543-     salt_4      db '@ReleaseControl'
   544 00000699 6F6E74726F6C       
   545 0000069F 00<rept>                            times (256-($-salt_4))  db 0
   546 00000790 [98030000]                          dd sleep_current_task
   547 00000794 3800                                dw kernel_code_seg_sel
   548                                  
   549                                  salt_item_len   equ $-salt_4
   550                                  salt_items      equ ($-salt)/salt_item_len
   551                                  ;}}}
   552                                  
   553 00000796 00000000                prgman_tss  dd 0
   554 0000079A 0000                                dw 0
   555                                  
   556                                  kernel_data_end:
   557                                  ;}}}
   558                                  
   559                                  ;内核代码段;{{{
   560                                  SECTION kernel_code vstart=0
   561                                  
   562                                  ;fill_descriptor_in_ldt函数;{{{
   563                                  ;
   564                                  ;作用：
   565                                  ;    将描述符添加到ldt表
   566                                  ;参数：
   567                                  ;    edx:eax = 描述符
   568                                  ;    ebx = tcb线性基地址
   569                                  ;输出：
   570                                  ;    cx = 选择子
   571                                  fill_descriptor_in_ldt:
   572 00000000 50                          push eax
   573 00000001 52                          push edx
   574 00000002 1E                          push ds
   575                                  
   576 00000003 51                          push ecx
   577                                  
   578 00000004 B908000000                  mov ecx,mem_0_4_gb_seg_sel
   579 00000009 8ED9                        mov ds,ecx
   580                                  
   581 0000000B 50                          push eax
   582 0000000C 8B4B0C                      mov ecx,[ebx+0x0c]          ;获取LDT基地址     
   583 0000000F 0FB7430A                    movzx eax,word [ebx+0x0a]   ;获取LDT界限
   584 00000013 6640                        inc ax
   585 00000015 01C1                        add ecx,eax
   586 00000017 58                          pop eax
   587                                  
   588 00000018 8901                        mov [ecx],eax               ;填写描述符
   589 0000001A 895104                      mov [ecx+0x04],edx
   590 0000001D 6681430A0800                add word [ebx+0x0a],8       ;更新LDT界限值
   591                                  
   592 00000023 0FB7430A                    movzx eax,word [ebx+0x0a]
   593 00000027 31D2                        xor edx,edx
   594 00000029 B908000000                  mov ecx,8
   595 0000002E F7F1                        div ecx
   596                                  
   597 00000030 59                          pop ecx
   598                                      
   599 00000031 66C1E003                    shl ax,3
   600 00000035 660D0700                    or ax,0x7                   ;LDT,RPL=3
   601 00000039 6689C1                      mov cx,ax
   602                                  
   603 0000003C 1F                          pop ds
   604 0000003D 5A                          pop edx
   605 0000003E 58                          pop eax
   606                                  
   607 0000003F C3                          ret
   608                                  ;}}}
   609                                  
   610                                  ;append_to_tcb_link函数;{{{
   611                                  ;
   612                                  ;作用：
   613                                  ;    将TCB添加到TCB链中
   614                                  ;参数：
   615                                  ;    ecx = TCB线性基地址
   616                                  ;输出：
   617                                  ;    无
   618                                  append_to_tcb_link:
   619 00000040 50                          push eax
   620 00000041 1E                          push ds
   621 00000042 06                          push es
   622                                      
   623 00000043 B830000000                  mov eax,kernel_data_seg_sel
   624 00000048 8ED8                        mov ds,eax
   625                                  
   626 0000004A B808000000                  mov eax,mem_0_4_gb_seg_sel
   627 0000004F 8EC0                        mov es,eax
   628                                  
   629 00000051 A1[7A010000]                mov eax,[tcb_chain]
   630 00000056 268901                      mov [es:ecx],eax
   631 00000059 890D[7A010000]              mov [tcb_chain],ecx
   632                                  
   633 0000005F 07                          pop es
   634 00000060 1F                          pop ds
   635 00000061 58                          pop eax
   636                                  
   637 00000062 C3                          ret
   638                                  ;}}}
   639                                  
   640                                  ;load_relocate_user_program函数{{{
   641                                  ;
   642                                  ;作用：
   643                                  ;   从硬盘加载用户程序到内存，为其添加段选择子并重定位salt
   644                                  ;参数：
   645                                  ;   push = 用户程序起始逻辑扇区号
   646                                  ;   push = TCB线性基地址
   647                                  ;输出：
   648                                  ;   无
   649                                  load_relocate_user_program:
   650 00000063 60                          pushad
   651 00000064 1E                          push ds
   652 00000065 06                          push es
   653                                  
   654 00000066 B830000000                  mov eax,kernel_data_seg_sel
   655 0000006B 8ED8                        mov ds, eax
   656                                  
   657 0000006D 89E5                        mov ebp,esp
   658                                  
   659                                      ;{{{ 加载用户程序到内存
   660                                      ;加载用户程序的第一扇区
   661 0000006F 8B7530                      mov esi,[ebp+12*4]      ;12=push tcb基地址(1) + pushad(8) +
   662                                                              ;   push ds(1) + push es(1) + push cs(1)
   663 00000072 89F0                        mov eax,esi
   664 00000074 BB[7E010000]                mov ebx,user_header_buffer
   665 00000079 9A[CC000000]2800            call kernel_sysroute_seg_sel:read_one_disk_sector
   666                                  
   667                                      ;从用户程序头部获取用户程序字节数
   668 00000080 A1[7E010000]                mov eax,[user_header_buffer]
   669 00000085 89C3                        mov ebx,eax
   670 00000087 81E300FEFFFF                and ebx,0xfffffe00
   671 0000008D 81C300020000                add ebx,512
   672 00000093 A9FF010000                  test eax,0x1ff
   673 00000098 0F45C3                      cmovnz eax,ebx
   674                                  
   675                                      ;为用户程序分配内存
   676 0000009B 89C1                        mov ecx,eax
   677 0000009D 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
   678 000000A4 51                          push ecx
   679                                  
   680                                      ;加载整个用户程序
   681 000000A5 51                          push ecx
   682 000000A6 31D2                        xor edx,edx
   683 000000A8 BB00020000                  mov ebx,512
   684 000000AD F7F3                        div ebx
   685 000000AF B901000000                  mov ecx,1
   686 000000B4 81FA00000000                cmp edx,0
   687 000000BA 0F45D1                      cmovnz edx,ecx
   688 000000BD 01D0                        add eax,edx
   689 000000BF 59                          pop ecx
   690                                  
   691 000000C0 BA08000000                  mov edx,mem_0_4_gb_seg_sel
   692 000000C5 8EDA                        mov ds,edx
   693 000000C7 89CB                        mov ebx,ecx
   694 000000C9 89C1                        mov ecx,eax
   695 000000CB 89F0                        mov eax,esi
   696                                  .read_sector:
   697 000000CD 9A[CC000000]2800            call kernel_sysroute_seg_sel:read_one_disk_sector
   698 000000D4 40                          inc eax
   699 000000D5 E2F6                        loop .read_sector
   700                                      ;}}}
   701                                  
   702 000000D7 8B7D2C                      mov edi,[ebp+11*4]          ;取TCB线性基地址
   703                                      
   704 000000DA 59                          pop ecx
   705 000000DB 894F06                      mov [edi+0x06],ecx          ;填写用户程序基地址到TCB中
   706 000000DE 51                          push ecx
   707                                  
   708                                      ;{{{ 创建LDT并填写到TCB中
   709 000000DF BB90010000                  mov ebx,400
   710 000000E4 89D9                        mov ecx,ebx         ;8*50 LDT内最多50条描述符
   711 000000E6 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
   712                                  
   713 000000ED 89C8                        mov eax,ecx
   714 000000EF 4B                          dec ebx
   715 000000F0 B900E24000                  mov ecx,0x0040e200
   716 000000F5 89470C                      mov [edi+0x0c],eax          ;填写LDT基地址到TCB
   717 000000F8 66C7470AFFFF                mov word [edi+0x0a],0xffff  ;填写LDT当前已用界限到TCB
   718                                                                  ;下次往LDT安装新描述符时, 0xffff+1正好为0
   719 000000FE 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   720 00000105 9A[4D010000]2800            call kernel_sysroute_seg_sel:install_gdt_descriptor
   721 0000010C 66894F10                    mov [edi+0x10],cx           ;填写LDT选择子到TCB
   722                                      ;}}}
   723                                  
   724 00000110 59                          pop ecx                     ;恢复用户程序内存线性地址
   725 00000111 89CF                        mov edi,ecx
   726                                  
   727 00000113 8B752C                      mov esi,[ebp+11*4]          ;TCB基地址
   728                                  
   729                                      ;{{{ 处理用户程序header段
   730 00000116 89F8                        mov eax,edi
   731 00000118 8B5F04                      mov ebx,[edi+0x04]
   732 0000011B 4B                          dec ebx
   733 0000011C B900F24000                  mov ecx,0x0040f200
   734 00000121 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   735 00000128 89F3                        mov ebx,esi
   736 0000012A E8D1FEFFFF                  call fill_descriptor_in_ldt
   737 0000012F 66894F04                    mov [edi+0x04],cx           ;回填段选择子
   738 00000133 66894F06                    mov [edi+0x06],cx
   739 00000137 66894E44                    mov [esi+0x44],cx           ;填写头部选择子到TCB
   740                                      ;}}}
   741                                      
   742                                      ;{{{ 处理用户数据段
   743 0000013B 89F8                        mov eax,edi
   744 0000013D 034710                      add eax,[edi+0x10]
   745 00000140 8B5F14                      mov ebx,[edi+0x14]
   746 00000143 4B                          dec ebx
   747 00000144 B900F24000                  mov ecx,0x0040f200
   748 00000149 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   749 00000150 89F3                        mov ebx,esi
   750 00000152 E8A9FEFFFF                  call fill_descriptor_in_ldt
   751 00000157 66894F10                    mov [edi+0x10],cx           ;回填段选择子
   752 0000015B 66894F12                    mov [edi+0x12],cx
   753                                      ;}}}
   754                                      
   755                                      ;{{{ 处理用户代码段
   756 0000015F 89F8                        mov eax,edi
   757 00000161 03471C                      add eax,[edi+0x1c]
   758 00000164 8B5F20                      mov ebx,[edi+0x20]
   759 00000167 4B                          dec ebx
   760 00000168 B900F84000                  mov ecx,0x0040f800
   761 0000016D 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   762 00000174 89F3                        mov ebx,esi
   763 00000176 E885FEFFFF                  call fill_descriptor_in_ldt
   764 0000017B 66894F1C                    mov [edi+0x1c],cx           ;回填段选择子
   765 0000017F 66894F1E                    mov [edi+0x1e],cx
   766                                      ;}}}
   767                                  
   768                                      ;{{{ 处理用户栈段
   769 00000183 8B470C                      mov eax,[edi+0x0c]
   770 00000186 31D2                        xor edx,edx
   771 00000188 BB00100000                  mov ebx,4096
   772 0000018D F7E3                        mul ebx
   773 0000018F 89C1                        mov ecx,eax
   774 00000191 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
   775 00000198 89C3                        mov ebx,eax
   776 0000019A 89C8                        mov eax,ecx
   777 0000019C B900F64000                  mov ecx,0x0040f600
   778 000001A1 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   779 000001A8 89F3                        mov ebx,esi
   780 000001AA E851FEFFFF                  call fill_descriptor_in_ldt
   781 000001AF 66894F08                    mov [edi+0x08],cx           ;回填段选择子
   782 000001B3 66894F0A                    mov [edi+0x0a],cx
   783                                      ;}}}
   784                                  
   785                                      ;{{{ 重定位salt
   786 000001B7 8B4F24                      mov ecx,[edi+0x24]
   787 000001BA 89FE                        mov esi,edi
   788 000001BC 81C628000000                add esi,0x28
   789                                  
   790 000001C2 B830000000                  mov eax,kernel_data_seg_sel
   791 000001C7 8EC0                        mov es,eax
   792                                  
   793 000001C9 FC                          cld
   794                                  
   795 000001CA 57                          push edi
   796                                  .for_each_user_item:
   797 000001CB 56                          push esi
   798 000001CC 51                          push ecx
   799 000001CD BF[7E030000]                mov edi,salt
   800                                  
   801 000001D2 89F0                        mov eax,esi
   802 000001D4 89FB                        mov ebx,edi
   803                                  .next_kernel_salt_item:
   804 000001D6 89C6                        mov esi,eax
   805 000001D8 89DF                        mov edi,ebx
   806 000001DA 81C306010000                add ebx,256+6
   807 000001E0 B940000000                  mov ecx,64          ;256/4=64
   808 000001E5 F3A7                        repe cmpsd
   809 000001E7 75ED                        jnz .next_kernel_salt_item
   810                                  
   811 000001E9 268B07                      mov eax,[es:edi]
   812 000001EC 26668B5F04                  mov bx,[es:edi+0x4]
   813 000001F1 898600FFFFFF                mov [esi-256],eax
   814 000001F7 6681CB0300                  or bx,0x3               ;使RPL=3
   815 000001FC 66899E04FFFFFF              mov [esi-252],bx
   816                                  
   817 00000203 59                          pop ecx
   818 00000204 5E                          pop esi
   819 00000205 81C600010000                add esi,256
   820 0000020B E2BE                        loop .for_each_user_item
   821 0000020D 5F                          pop edi
   822                                      ;}}}
   823                                  
   824 0000020E 8B752C                      mov esi,[ebp+11*4]          ;TCB线性基地址
   825                                  
   826                                      ;{{{ 创建0特权级栈
   827 00000211 B800100000                  mov eax,4096
   828 00000216 89461A                      mov [esi+0x1a],eax          ;填写0特权级栈长度到TCB
   829 00000219 C16E1A0C                    shr dword [esi+0x1a],12
   830 0000021D 89C1                        mov ecx,eax
   831 0000021F 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
   832 00000226 01C8                        add eax,ecx
   833 00000228 BBFEFF0F00                  mov ebx,0xffffe
   834 0000022D B90096C000                  mov ecx,0x00c09600
   835 00000232 89461E                      mov [esi+0x1e],eax          ;填写0特权级栈基地址到TCB
   836 00000235 C7462400000000              mov dword [esi+0x24],0      ;填写0特权级栈初始ESP到TCB
   837 0000023C 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   838 00000243 89F3                        mov ebx,esi
   839 00000245 E8B6FDFFFF                  call fill_descriptor_in_ldt
   840 0000024A 6681E1FCFF                  and cx,0xfffc               ;设置RPL=0
   841 0000024F 66894E22                    mov [esi+0x22],cx           ;填写0特权级栈选择子到TCB
   842                                      ;}}}
   843                                  
   844                                      ;{{{ 创建1特权级栈
   845 00000253 B800100000                  mov eax,4096
   846 00000258 894628                      mov [esi+0x28],eax
   847 0000025B C16E280C                    shr dword [esi+0x28],12
   848 0000025F 89C1                        mov ecx,eax
   849 00000261 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
   850 00000268 01C8                        add eax,ecx
   851 0000026A BBFEFF0F00                  mov ebx,0xffffe
   852 0000026F B900B6C000                  mov ecx,0x00c0b600
   853 00000274 89462C                      mov [esi+0x2c],eax
   854 00000277 C7463200000000              mov dword [esi+0x32],0
   855 0000027E 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   856 00000285 89F3                        mov ebx,esi
   857 00000287 E874FDFFFF                  call fill_descriptor_in_ldt
   858 0000028C 6681C90100                  or cx,1
   859 00000291 6681E1FD00                  and cx,0xfd
   860 00000296 66894E30                    mov [esi+0x30],cx
   861                                      ;}}}
   862                                  
   863                                      ;{{{ 创建2特权级栈
   864 0000029A B800100000                  mov eax,4096
   865 0000029F 894636                      mov [esi+0x36],eax
   866 000002A2 C16E360C                    shr dword [esi+0x36],12
   867 000002A6 89C1                        mov ecx,eax
   868 000002A8 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
   869 000002AF 01C8                        add eax,ecx
   870 000002B1 BBFEFF0F00                  mov ebx,0xffffe
   871 000002B6 B900D6C000                  mov ecx,0x00c0d600
   872 000002BB 89463A                      mov [esi+0x3a],eax
   873 000002BE C7464000000000              mov dword [esi+0x40],0
   874 000002C5 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   875 000002CC 89F3                        mov ebx,esi
   876 000002CE E82DFDFFFF                  call fill_descriptor_in_ldt
   877 000002D3 6681C90200                  or cx,2
   878 000002D8 6681E1FE00                  and cx,0xfe
   879 000002DD 66894E3E                    mov [esi+0x3e],cx
   880                                      ;}}} 
   881                                  
   882                                      ;{{{ 创建TSS
   883 000002E1 B968000000                  mov ecx,104
   884 000002E6 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
   885 000002ED 894E14                      mov [esi+0x14],ecx      ;填写TSS线性基地址到TCB中
   886                                  
   887                                      ;为用户程序TSS填写必要字段
   888                                  
   889                                      ;esi => TCB基地址
   890                                      ;ecx => TSS基地址
   891                                  
   892 000002F0 668B4622                    mov ax,[esi+0x22]       ;设置ss0
   893 000002F4 66894108                    mov [ecx+8],ax
   894 000002F8 8B4624                      mov eax,[esi+0x24]      ;设置esp0
   895 000002FB 894104                      mov [ecx+4],eax
   896                                  
   897 000002FE 668B4630                    mov ax,[esi+0x30]       ;设置ss1
   898 00000302 66894110                    mov [ecx+16],ax
   899 00000306 8B4632                      mov eax,[esi+0x32]      ;设置esp1
   900 00000309 89410C                      mov [ecx+12],eax
   901                                  
   902 0000030C 668B463E                    mov ax,[esi+0x3e]       ;设置ss2
   903 00000310 66894118                    mov [ecx+24],ax
   904 00000314 8B4640                      mov eax,[esi+0x40]      ;设置esp2
   905 00000317 894114                      mov [ecx+20],eax
   906                                  
   907 0000031A 668B4610                    mov ax,[esi+0x10]       ;设置ldt
   908 0000031E 66894160                    mov [ecx+96],ax
   909                                  
   910 00000322 66C741640000                mov word [ecx+100],0    ;T=0
   911                                  
   912 00000328 C7411C00000000              mov dword [ecx+28],0    ;CR3=0
   913                                  
   914 0000032F 66C741666800                mov word [ecx+102],104  ;设置I/O bitmap
   915                                  
   916 00000335 8B7E06                      mov edi,[esi+0x06]      ;从TCB中获取用户程序基地址
   917                                  
   918 00000338 668B471C                    mov ax,[edi+0x1c]       ;设置cs
   919 0000033C 6689414C                    mov [ecx+76],ax
   920 00000340 8B4718                      mov eax,[edi+0x18]      ;设置eip
   921 00000343 894120                      mov [ecx+32],eax
   922                                  
   923 00000346 668B4708                    mov ax,[edi+0x08]       ;设置ss
   924 0000034A 66894150                    mov [ecx+80],ax
   925 0000034E C7413800000000              mov dword [ecx+56],0    ;设置esp
   926                                  
   927 00000355 668B4644                    mov ax,[esi+0x44]       ;设置ds为程序头部段
   928 00000359 66894154                    mov [ecx+84],ax
   929                                  
   930 0000035D 66C741480000                mov word [ecx+72],0     ;es=0
   931 00000363 66C741580000                mov word [ecx+88],0     ;fs=0
   932 00000369 66C7415C0000                mov word [ecx+92],0     ;gs=0
   933                                  
   934 0000036F 9C                          pushfd
   935 00000370 5A                          pop edx
   936 00000371 895124                      mov dword [ecx+36],edx  ;eflags
   937                                  
   938 00000374 89C8                        mov eax,ecx
   939 00000376 BB67000000                  mov ebx,104-1
   940 0000037B B900894000                  mov ecx,0x00408900      ;TSS, DPL=0
   941 00000380 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
   942 00000387 9A[4D010000]2800            call kernel_sysroute_seg_sel:install_gdt_descriptor
   943 0000038E 66894E18                    mov [esi+0x18],cx       ;填写TSS段选择子到TCB中
   944                                      ;}}}
   945                                  
   946 00000392 07                          pop es
   947 00000393 1F                          pop ds
   948 00000394 61                          popad
   949                                  
   950 00000395 C20800                      ret 8
   951                                      ;}}}
   952                                  
   953                                  ;sleep_current_task{{{
   954                                  sleep_current_task:
   955 00000398 53                          push ebx
   956 00000399 1E                          push ds
   957                                  
   958 0000039A 9C                          pushfd              ;将eflags压栈
   959 0000039B 5B                          pop ebx             ;将eflags出栈到ebx中
   960                                  
   961                                      ;根据eflags的NT位（bit14）来决定用iret还是jmp来进行任务切换
   962 0000039C F7C300400000                test ebx,0x4000
   963 000003A2 7406                        jz .jmp
   964                                  
   965 000003A4 CF                          iretd
   966 000003A5 E906000000                  jmp .ret
   967                                  
   968                                  .jmp:
   969 000003AA FF2D[96070000]              jmp far [prgman_tss]
   970                                  
   971                                  .ret:
   972 000003B0 1F                          pop ds
   973 000003B1 5B                          pop ebx
   974                                  
   975 000003B2 CB                          retf
   976                                      ;}}}
   977                                  
   978                                  ;start{{{
   979                                  start:
   980 000003B3 B830000000                  mov eax,kernel_data_seg_sel
   981 000003B8 8ED8                        mov ds,eax
   982                                  
   983 000003BA B820000000                  mov eax,kernel_stack_seg_sel
   984 000003BF 8ED0                        mov ss,eax
   985 000003C1 31E4                        xor esp,esp
   986                                  
   987                                      ;显示CPU信息;{{{
   988 000003C3 BB[1A000000]                mov ebx,return_str
   989 000003C8 9A[00000000]2800            call kernel_sysroute_seg_sel:putstr
   990                                  
   991 000003CF BB[4E000000]                mov ebx,cpu_brnd0
   992 000003D4 9A[00000000]2800            call kernel_sysroute_seg_sel:putstr
   993                                  
   994                                      ;使用cpuid获取cpu信息
   995 000003DB B802000080                  mov eax,0x80000002
   996 000003E0 0FA2                        cpuid
   997 000003E2 A3[59000000]                mov [cpu_brand+0x00], eax
   998 000003E7 891D[5D000000]              mov [cpu_brand+0x04], ebx
   999 000003ED 890D[61000000]              mov [cpu_brand+0x08], ecx
  1000 000003F3 8915[65000000]              mov [cpu_brand+0x0c], edx
  1001                                  
  1002 000003F9 B803000080                  mov eax,0x80000003
  1003 000003FE 0FA2                        cpuid
  1004 00000400 A3[69000000]                mov [cpu_brand+0x10], eax
  1005 00000405 891D[6D000000]              mov [cpu_brand+0x14], ebx
  1006 0000040B 890D[71000000]              mov [cpu_brand+0x18], ecx
  1007 00000411 8915[75000000]              mov [cpu_brand+0x1c], edx
  1008                                  
  1009 00000417 B804000080                  mov eax,0x80000004
  1010 0000041C 0FA2                        cpuid
  1011 0000041E A3[79000000]                mov [cpu_brand+0x20], eax
  1012 00000423 891D[7D000000]              mov [cpu_brand+0x24], ebx
  1013 00000429 890D[81000000]              mov [cpu_brand+0x28], ecx
  1014 0000042F 8915[85000000]              mov [cpu_brand+0x2c], edx
  1015                                  
  1016 00000435 BB[59000000]                mov ebx,cpu_brand
  1017 0000043A 9A[00000000]2800            call kernel_sysroute_seg_sel:putstr
  1018                                      ;}}}
  1019                                  
  1020                                      ;显示msg_1;{{{
  1021 00000441 BB[1A000000]                mov ebx,return_str
  1022 00000446 9A[00000000]2800            call kernel_sysroute_seg_sel:putstr
  1023 0000044D 9A[00000000]2800            call kernel_sysroute_seg_sel:putstr
  1024 00000454 BB[1D000000]                mov ebx,msg_1
  1025 00000459 9A[00000000]2800            call kernel_sysroute_seg_sel:putstr
  1026                                      ;}}}
  1027                                  
  1028                                      ;将k-salt中的段选择子改为调用门{{{
  1029 00000460 B904000000                  mov ecx,salt_items
  1030 00000465 BA[7E030000]                mov edx,salt
  1031                                  .next_kernel_salt_item:
  1032 0000046A 51                          push ecx
  1033 0000046B 668B8204010000              mov ax,[edx+260]                ;selector
  1034 00000472 8B9A00010000                mov ebx,[edx+256]               ;offset
  1035 00000478 66B900EC                    mov cx,0xec00                   ;111_0_1100_000_00000B
  1036 0000047C 52                          push edx
  1037 0000047D 9A[39010000]2800            call kernel_sysroute_seg_sel:make_call_gate_descriptor
  1038 00000484 9A[4D010000]2800            call kernel_sysroute_seg_sel:install_gdt_descriptor
  1039 0000048B 5A                          pop edx
  1040 0000048C 66898A04010000              mov [edx+260],cx                ;回填调用门选择子
  1041 00000493 81C206010000                add edx,salt_item_len
  1042 00000499 59                          pop ecx
  1043 0000049A E2CE                        loop .next_kernel_salt_item
  1044                                      ;}}}
  1045                                  
  1046                                      ;为当前内核创建一个任务，称为程序管理任务{{{
  1047 0000049C B808000000                  mov eax,mem_0_4_gb_seg_sel
  1048 000004A1 8ED8                        mov ds,eax
  1049                                  
  1050                                      ;分配TSS内存
  1051 000004A3 B968000000                  mov ecx,104
  1052 000004A8 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
  1053                                  
  1054                                      ;填写TSS部分字段
  1055 000004AF 66C7010000                  mov word [ecx],0        ;上一个任务链接置为0
  1056 000004B4 66C741600000                mov word [ecx+96],0     ;LDT置为0
  1057 000004BA 66C741640000                mov word [ecx+100],0    ;T位置为0
  1058 000004C0 66C741666800                mov word [ecx+102],104  ;设置IO位图
  1059                                  
  1060                                      ;为TSS生成段描述符并安装到GDT中
  1061 000004C6 89C8                        mov eax,ecx
  1062 000004C8 BB67000000                  mov ebx,104-1
  1063 000004CD B900894000                  mov ecx,0x00408900
  1064 000004D2 9A[1B010000]2800            call kernel_sysroute_seg_sel:make_seg_descriptor
  1065 000004D9 9A[4D010000]2800            call kernel_sysroute_seg_sel:install_gdt_descriptor
  1066                                  
  1067 000004E0 B830000000                  mov eax,kernel_data_seg_sel
  1068 000004E5 8EC0                        mov es,eax
  1069                                  
  1070                                      ;将TSS选择子填入内核数据段prgman_tss内存处
  1071 000004E7 2666890D[9A070000]          mov word [es:prgman_tss+0x4],cx
  1072                                  
  1073                                      ;加载TSS
  1074 000004EF 0F00D9                      ltr cx
  1075                                      ;}}}
  1076                                  
  1077                                      ;第一个用户程序{{{
  1078                                  
  1079                                      ;分配TCB内存
  1080 000004F2 B946000000                  mov ecx,0x46
  1081 000004F7 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
  1082 000004FE E83DFBFFFF                  call append_to_tcb_link
  1083                                  
  1084                                      ;加载用户程序
  1085                                                                              ;用栈传参
  1086 00000503 6828000000                  push dword user1_prog_start_sector       ;用户程序硬盘起始扇区号
  1087 00000508 51                          push ecx                                ;TCB线性基地址
  1088 00000509 E855FBFFFF                  call load_relocate_user_program
  1089                                  
  1090 0000050E 51                          push ecx
  1091                                  
  1092                                      ;}}}
  1093                                  
  1094                                      ;第二个用户程序{{{
  1095                                      ;使用call发起任务切换
  1096                                  
  1097                                      ;分配TCB内存
  1098 0000050F B946000000                  mov ecx,0x46
  1099 00000514 9A[B0010000]2800            call kernel_sysroute_seg_sel:allocate_memory
  1100 0000051B E820FBFFFF                  call append_to_tcb_link
  1101                                  
  1102                                      ;加载用户程序
  1103                                                                              ;用栈传参
  1104 00000520 6832000000                  push dword user2_prog_start_sector       ;用户程序硬盘起始扇区号
  1105 00000525 51                          push ecx                                ;TCB线性基地址
  1106 00000526 E838FBFFFF                  call load_relocate_user_program
  1107                                  
  1108                                      ;}}}
  1109                                  
  1110 0000052B B808000000                  mov eax,mem_0_4_gb_seg_sel
  1111 00000530 8ED8                        mov ds,eax
  1112                                  
  1113                                      ;循环切换到两个用户程序中
  1114 00000532 58                          pop eax
  1115 00000533 89CB                        mov ebx,ecx
  1116 00000535 B940010000                  mov ecx,80*4
  1117                                  .loop_task:
  1118 0000053A F7C101000000                test ecx,0x1
  1119 00000540 7408                        jz .task_b
  1120                                  
  1121                                  .task_a:
  1122 00000542 FF5814                      call far [eax+0x14]
  1123 00000545 E903000000                  jmp .next_loop
  1124                                  
  1125                                  .task_b:
  1126 0000054A FF5B14                      call far [ebx+0x14]
  1127                                  
  1128                                  .next_loop:
  1129 0000054D E2EB                        loop .loop_task
  1130                                  
  1131 0000054F F4                          hlt
  1132                                      ;}}}
  1133                                  
  1134                                  kernel_code_end:
  1135                                  ;}}}
  1136                                  
  1137                                  ;{{{ kernel_tail段
  1138                                  SECTION kernel_tail
  1139                                  kernel_end:
  1140                                  ;}}}
  1141                                  
  1142                                  ; vim: set syntax=nasm:
