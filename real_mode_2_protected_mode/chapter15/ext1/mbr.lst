     1                                  ;mbr程序
     2                                  ;
     3                                  ;mbr程序的加载：
     4                                  ;   bios程序完成自身工作后将根据配置的启动介质顺序去找可启动块
     5                                  ;   （以0x55aa结尾的512个字节），硬盘上的这块区域对应为0面0道1扇区
     6                                  ;   （一个扇区512个字节），通常称做mbr，bios找到后将这512字节加载到
     7                                  ;   内存0x0:0x7c00处，然后执行指令：
     8                                  ;   jmp 0x0:0x7c00
     9                                  ;   至此，CPU控制权转移到了mbr程序里
    10                                  ;   注：bios工作在实模式下
    11                                  ; 
    12                                  ;mbr程序所做的事：
    13                                  ;   一句话说，就是加载内核程序并将控制权转交给内核程序，具体事宜如下：
    14                                  ;   1. 从实模式进入保护模式
    15                                  ;       1.1 为进入保护模式做准备
    16                                  ;           1.1.1 创建GDT并加载到GDTR中
    17                                  ;               1.1.1.1 0#号空描述符
    18                                  ;               1.1.1.2 内核代码段
    19                                  ;               1.1.1.3 内核栈段
    20                                  ;               1.1.1.4 内核数据段
    21                                  ;           1.1.2 打开A20地址线
    22                                  ;           1.1.3 关闭中断
    23                                  ;       1.2 设置PE位，进入保护模式
    24                                  ;       1.3 清流水线并串行化处理器
    25                                  ;   2. 加载内核程序并将CPU控制权转换给内核
    26                                  ;       1.1 加载内核程序到内存
    27                                  ;           1.1 内核程序位于硬盘指定扇区（宏core_start_sector中定义）
    28                                  ;           1.2 内核程序头部中包含了内核程序的字节数、执行入口、段的起始地址及长度
    29                                  ;           1.3 mbr读取指定扇区（即内核程序头部）到预置内存地址
    30                                  ;           1.4 mbr根据内核头部信息读取剩余的内核程序
    31                                  ;       1.2 mbr根据内核头部的段信息为内核段在GDT中添加段描述符
    32                                  ;       1.3 mbr根据内核头部的执行入口信息转入内核执行
    33                                  
    34                                  ;宏定义
    35                                  kernel_start_sector equ 05              ;内核在硬盘中的起始逻辑扇区号
    36                                  kernel_base_address equ 0x00040000      ;内核要加载到的内存起始地址
    37                                  
    38                                  ;    _______ __ 0xffffffff (4GB)
    39                                  ;   |       |
    40                                  ;   |       |
    41                                  ;   |       |
    42                                  ;   |       |
    43                                  ;   |       |
    44                                  ;   |       |
    45                                  ;   |       |
    46                                  ;   |       |
    47                                  ;   |       |
    48                                  ;   |       |
    49                                  ;   |       |
    50                                  ;   |       |
    51                                  ;   |_______|__ kernel 0x00040000
    52                                  ;   |       |
    53                                  ;   |       |
    54                                  ;   |       |
    55                                  ;   |       |
    56                                  ;   |       |-- 显存段描述符(base 0x000b8000, len 0x7fff)
    57                                  ;   |       |-- 栈段描述符(base 0x0000:7c00, len 0xffffe 4KB)
    58                                  ;   |       |-- mbr代码段描述符(0x0000:0x7c00, len 0x1ff)
    59                                  ;   |       |-- 0-4GB内存数据段描述符
    60                                  ;   |_______|-- 空描述符 _______ GDT 0x0000:0x7e00 
    61                                  ;   |       |;   |       | |
    62                                  ;   |       | |
    63                                  ;   |       | |-- 512 bytes (512 = 0x1ff + 1 = 0x200)
    64                                  ;   |       | |
    65                                  ;   |       | |
    66                                  ;   |_______|/__ mbr 0x0000:0x7c00
    67                                  ;   |       |;   |       | |
    68                                  ;   |       | |
    69                                  ;   |       | |
    70                                  ;   |       | |
    71                                  ;   |       | |-- stack
    72                                  ;   |       | |
    73                                  ;   |       | |
    74                                  ;   |       | |
    75                                  ;   |       | |
    76                                  ;   |_______|/__ 0x0
    77                                  
    78                                  
    79                                  ;当前在实模式下，为进入保护模式做准备
    80                                  
    81 00000000 8CC8                    mov ax,cs   ;bios执行jmp 0x0:0x7c00后到此，cs值应为0
    82 00000002 8ED0                    mov ss,ax
    83 00000004 BC007C                  mov sp,0x7c00
    84                                  
    85                                  ;实模式下以 段：偏移 方式访问内存，所以将GDT的物理地址转换成这种形式
    86 00000007 6631D2                  xor edx,edx
    87 0000000A 2E66A1[AC7D]            mov eax,[cs:0x7c00+pgdt+0x2]
    88 0000000F 66BB10000000            mov ebx,16
    89 00000015 66F7F3                  div ebx             ; div r32   edx:eax / r32 => eax ... edx
    90 00000018 8ED8                    mov ds,eax
    91 0000001A 6689D3                  mov ebx,edx         ; GDT的物理地址被转换成了ds:ebx
    92                                  
    93                                  ;创建段描述符
    94                                  
    95                                  ;segment descriptor
    96                                  ;        <--------------------------------------------------------------^
    97                                  ;        |31      24|23 22  21 20  19       16|15 14  12 11 8|7        0|
    98                                  ;        |----------|-------------------------|--------------|----------^
    99                                  ;4-7byte:|Base 31:24|G  D/B L  AVL Limit 19:16|P  DPL S  Type|Base 23:16|
   100                                  ;        |----------|-------------------------|--------------|----------^
   101                                  ;0-3byte:|            Base 15:0               |        Limit 15:0       |
   102                                  ;        <---------------------------------------------------------------
   103                                  ;
   104                                  ; G    : granularity, 0 - byte, 1 - 4KB
   105                                  ; D/B  : 1 - 32bit operand/address, 0 - 16bit operand/address
   106                                  ; L    : 1 - 64bit code, 0 - 32/16bit code
   107                                  ; AVL  : Reserved, set 0
   108                                  ; P    : 1 - Present in memory, 0 - not Present in memory
   109                                  ; DPL  : descripter privilage level, 00->11
   110                                  ; S    : 0 - system segment, 1 - code or data segment
   111                                  ; Type : 0 E W A for data segment
   112                                  ;           E: extend-down
   113                                  ;           W: Writable
   114                                  ;           A: Accessed
   115                                  ;        1 C R A for code segment
   116                                  ;           C: confirming
   117                                  ;           R: readable
   118                                  ;           A: Accessed
   119                                  
   120                                  ;跳过#0空描述符，只需留下内存空间即可
   121                                  
   122                                  ;0-4G内存访问描述符
   123 0000001D 6667C74308FFFF0000      mov dword [ebx+0x08],0x0000ffff  ;Base:0x0, Limit:0xfffff
   124 00000026 6667C7430C0092CF00      mov dword [ebx+0x0c],0x00cf9200  ;G=1,D=1,L=0,DPL=0,S=1,type=0010
   125                                  
   126                                  ;显存段描述符
   127 0000002F 6667C74310FF7F0080      mov dword [ebx+0x10],0x80007fff  ;Base:0x000b8000, Limit: 0x07fff (0x8000=8*4K=32K)
   128 00000038 6667C743140B924000      mov dword [ebx+0x14],0x0040920b  ;G=0,D=1,L=0,DPL=0,S=1,type=0010
   129                                  
   130                                  ;mbr进入保护模式后代码段的描述符
   131 00000041 6667C74318FF01007C      mov dword [ebx+0x18],0x7c0001ff  ;Base:0x00007c00, Limit: 0x001ff (512=0x200)
   132 0000004A 6667C7431C00984000      mov dword [ebx+0x1c],0x00409800  ;G=0,D=1,L=0,DPL=0,S=1,type=1000
   133                                  
   134                                  ;mbr进入保护模式后栈段的描述符
   135 00000053 6667C74320007C007C      mov dword [ebx+0x20],0x7c007c00  ;Base: 0x00007c00, Limit:0x07c00(not 0xffffe?)
   136 0000005C 6667C7432400964000      mov dword [ebx+0x24],0x00409600  ;G=0,B=1,L=0,DPL=0,S=1,type=0110, expand-down
   137                                  
   138                                  ;设置GDT的界限
   139 00000065 2EC706[AA7D]2700        mov word [cs:0x7c00+pgdt],39     ;(5*8-1)
   140                                  
   141                                  ;加载GDT
   142 0000006C 2E0F0116[AA7D]          lgdt [cs:0x7c00+pgdt]
   143                                  
   144                                  ;打开A20地址线
   145                                  ;方法：将0x92端口（属于ICH控制器，8位宽）的bit1置1
   146 00000072 E492                    in al,0x92
   147 00000074 0C02                    or al,00000010B
   148 00000076 E692                    out 0x92,al
   149                                  
   150                                  ;屏蔽可屏蔽的中断
   151 00000078 FA                      cli
   152                                  
   153                                  ;方法：将CR0寄存器的bit0(PE位)置为1
   154 00000079 0F20C0                  mov eax,cr0
   155 0000007C 660D01000000            or eax,0x1
   156 00000082 0F22C0                  mov cr0,eax
   157                                  
   158                                  ;已经进入了保护模式
   159                                  
   160                                  ;隐式设置cs并清空流水线
   161                                  
   162                                  ;Segment Selector
   163                                  ;   <------------------------------
   164                                  ;   |15                 3  2  1  0|
   165                                  ;   |-----------------------------|
   166                                  ;   |Index 15:3         |  TI RPL |
   167                                  ;   <------------------------------
   168                                  ; Index  : index in GDT/LDT
   169                                  ; TI     : 0 - GDT, 1 - LDT
   170                                  ; RPL    : Request Privilege Level
   171                                  
   172 00000085 EA[8A00]1800            jmp 0x0018:flush    ;代码段位于GDT的第3个段(1 1000)
   173                                  
   174                                  [bits 32]
   175                                  flush:
   176 0000008A B820000000                  mov eax,0x20    ;保护模式下的栈段
   177 0000008F 8ED0                        mov ss,eax
   178 00000091 31E4                        xor esp,esp
   179                                  
   180 00000093 B808000000                  mov eax,0x08    ;0-4G内存段
   181 00000098 8ED8                        mov ds,eax
   182                                  
   183 0000009A B805000000                  mov eax,kernel_start_sector     ;读取内核程序头一个扇区
   184 0000009F BF00000400                  mov edi,kernel_base_address
   185 000000A4 89FB                        mov ebx,edi
   186 000000A6 E890000000                  call read_one_disk_sector
   187                                  
   188                                      ;内核程序头部结构：
   189                                      ;   内核程序字节数 32bit
   190                                      ;   内核例程段偏移 32bit
   191                                      ;   内核数据段偏移 32bit
   192                                      ;   内核代码段偏移 32bit
   193                                      ;   内核执行入口点之段内偏移 32bit
   194                                      ;   内核执行入口点之段选择子 16bit
   195                                       
   196 000000AB 8B07                        mov eax,[edi]   ;获取内核程序字节数
   197 000000AD BA00000000                  mov edx,0
   198 000000B2 B900020000                  mov ecx,512
   199 000000B7 F7F1                        div ecx         ;将字节数转换为所占的扇区数
   200 000000B9 09D2                        or edx,edx      ;有余数则需再读一个扇区
   201 000000BB 7401                        jz .continue
   202 000000BD 40                          inc eax
   203                                  .continue:
   204 000000BE 48                          dec eax         ;减去已读的一个扇区
   205                                  
   206 000000BF 09C0                        or eax,eax      ;eax=0?
   207 000000C1 740F                        jz .setup
   208                                  
   209 000000C3 89C1                        mov ecx,eax     ;读取剩余扇区
   210 000000C5 B806000000                  mov eax,kernel_start_sector+1
   211                                  .read_disk:
   212 000000CA E86C000000                  call read_one_disk_sector
   213 000000CF 40                          inc eax
   214 000000D0 E2F8                        loop .read_disk
   215                                  
   216                                  .setup:
   217 000000D2 8B35[AC7D0000]              mov esi,[0x7c00+pgdt+0x02]  ;gdt基地址 
   218                                  
   219 000000D8 8B4704                      mov eax,[edi+0x04]          ;内核例程段
   220 000000DB 8B5F08                      mov ebx,[edi+0x08]          ;段尾-段首-1=段界限
   221 000000DE 29C3                        sub ebx,eax
   222 000000E0 4B                          dec ebx
   223 000000E1 01F8                        add eax,edi
   224 000000E3 B900984000                  mov ecx,0x00409800          ;属性
   225 000000E8 E89D000000                  call make_seg_descriptor
   226 000000ED 894628                      mov [esi+0x28],eax
   227 000000F0 89562C                      mov [esi+0x2c],edx
   228                                  
   229 000000F3 8B4708                      mov eax,[edi+0x08]          ;内核数据段
   230 000000F6 8B5F0C                      mov ebx,[edi+0x0c]
   231 000000F9 29C3                        sub ebx,eax
   232 000000FB 4B                          dec ebx
   233 000000FC 01F8                        add eax,edi
   234 000000FE B900924000                  mov ecx,0x00409200
   235 00000103 E882000000                  call make_seg_descriptor
   236 00000108 894630                      mov [esi+0x30],eax
   237 0000010B 895634                      mov [esi+0x34],edx
   238                                  
   239 0000010E 8B470C                      mov eax,[edi+0x0c]          ;内核代码段
   240 00000111 8B1F                        mov ebx,[edi+0x00]          ;程序总长度
   241 00000113 29C3                        sub ebx,eax
   242 00000115 4B                          dec ebx
   243 00000116 01F8                        add eax,edi
   244 00000118 B900984000                  mov ecx,0x00409800
   245 0000011D E868000000                  call make_seg_descriptor
   246 00000122 894638                      mov [esi+0x38],eax
   247 00000125 89563C                      mov [esi+0x3c],edx
   248                                  
   249 00000128 668105[AA7D0000]18-         add word [0x7c00+pgdt],24       ;更新GDT界限(3*8)
   250 00000130 00                 
   251 00000131 0F0115[AA7D0000]            lgdt [0x7c00+pgdt]
   252                                  
   253 00000138 FF6F10                      jmp far [edi+0x10]          ;执行内核入口点
   254                                  
   255                                  ;从硬盘读取一个扇区（512字节）
   256                                  ;参数：
   257                                  ;   eax = 逻辑扇区号
   258                                  ;   ds:ebx = 目标缓冲区地址
   259                                  ;输出：
   260                                  ;   ebx += 512
   261                                  
   262                                  ;硬盘的读写单位是一个扇区
   263                                  ;主硬盘控制器被分配到了八个端口：0x1f0 - 0x0f7
   264                                  ;用LBA28方式读写硬盘:
   265                                  ;   1. 往0x1f2端口(8bit)写入要读取的扇区数目
   266                                  ;   2. 将28位起始LBA扇区号写入0x1f3,0x1f4,0x1f5,0x1f6端口(均为8big)
   267                                  ;           ---------------------------------------------------------------------    
   268                                  ;           31 30 29 28 27      23              16              7               0
   269                                  ;           ---------------------------------------------------------------------    
   270                                  ;           |       0x1f6       |     0x1f5     |     0x1f4     |     0x1f3     | 
   271                                  ;           ---------------------------------------------------------------------    
   272                                  ;            1  |  1 |   \                                                     /
   273                                  ;               |    |    `````````````````````````````````````````````````````
   274                                  ;               |    |                           LBA28
   275                                  ;       0: CHS _|    |_ 0: 主硬盘(master)
   276                                  ;       1: LBA          1: 从硬盘(slave)
   277                                  ;   3. 往0x1f7端口(8bit)写入0x20，请求硬盘读
   278                                  ;   4. 等待硬盘准备好读写, 0x1f7既是命令端口也是状态端口，此时为状态端口，含义如下：
   279                                  ;       -----------------------------
   280                                  ;       7   6   5   4   3   2   1   0
   281                                  ;       -----------------------------
   282                                  ;       |               |           |           
   283                                  ;       |_ 0: 硬盘闲    |           |_ 0: 前一个命令执行成功
   284                                  ;          1: 硬盘忙    |              1: 前一个命令执行失败，具体原因查看0x1f1
   285                                  ;                       |_ 0: 硬盘未准备好与主机交换数据
   286                                  ;                          1: 硬盘已准备好与主机交换数据
   287                                  ;       当bit7为0且bit3为1时，表示可以进行读硬盘了
   288                                  ;   5. 从0x1f0端口(16bit)读取数据
   289                                  
   290                                  read_one_disk_sector:
   291 0000013B 50                          push eax
   292 0000013C 51                          push ecx
   293 0000013D 6652                        push dx
   294                                      
   295 0000013F 89C1                        mov ecx,eax
   296                                  
   297 00000141 66BAF201                    mov dx,0x1f2    ;1. 读取1个扇区
   298 00000145 B001                        mov al,1
   299 00000147 EE                          out dx,al
   300                                  
   301 00000148 6642                        inc dx          ;2.1 0x1f3 <= eax 7:0
   302 0000014A 89C8                        mov eax,ecx
   303 0000014C EE                          out dx,al
   304                                  
   305 0000014D 6642                        inc dx          ;2.2 0x1f4 <= eax 15:8
   306 0000014F C1E808                      shr eax,8
   307 00000152 EE                          out dx,al
   308                                  
   309 00000153 6642                        inc dx          ;2.3 0x1f5 <= eax 23:16
   310 00000155 C1E808                      shr eax,8
   311 00000158 EE                          out dx,al
   312                                  
   313 00000159 6642                        inc dx          ;2.4 0x1f6 <= eax 27:24
   314 0000015B C1E808                      shr eax,8
   315 0000015E 240F                        and al,0x0f
   316 00000160 0CE0                        or  al,0xe0     ;主硬盘+LBA方式
   317 00000162 EE                          out dx,al
   318                                  
   319 00000163 6642                        inc dx          ;3. 发送硬盘读命令
   320 00000165 B020                        mov al,0x20 
   321 00000167 EE                          out dx,al
   322                                  
   323                                  .wait:              ;4. 等待硬盘准备好可读
   324 00000168 EC                          in  al,dx
   325 00000169 2488                        and al,0x88
   326 0000016B 3C08                        cmp al,0x08
   327 0000016D 75F9                        jnz .wait
   328                                      
   329 0000016F B900010000                  mov ecx,256     ;5. 读取硬盘
   330 00000174 66BAF001                    mov dx,0x1f0
   331                                  .rw:
   332 00000178 66ED                        in  ax,dx 
   333 0000017A 668903                      mov [ebx],ax
   334 0000017D 81C302000000                add ebx,2
   335 00000183 E2F3                        loop .rw
   336                                  
   337 00000185 665A                        pop dx
   338 00000187 59                          pop ecx
   339 00000188 58                          pop eax
   340                                  
   341 00000189 C3                          ret
   342                                  
   343                                  ;构造段描述符
   344                                  ;参数：
   345                                  ;   eax = 段线性基地址（32位）
   346                                  ;   ebx = 段界限（20位）
   347                                  ;   ecx = 属性（各属性位都在原始位置，没用到的位为0）
   348                                  ;输出：
   349                                  ;   edx:eax 完整的段描述符
   350                                  make_seg_descriptor:
   351 0000018A 53                          push ebx
   352                                  
   353 0000018B 89C2                        mov edx,eax
   354 0000018D C1C010                      rol eax,16      ;Set Base 15:0
   355 00000190 6689D8                      mov ax,bx       ;Set Limit 15:0
   356                                  
   357 00000193 81E20000FFFF                and edx,0xffff0000
   358 00000199 C1C208                      rol edx,8
   359 0000019C 0FCA                        bswap edx       ;Set Base 31:24 and Base 23:16
   360                                  
   361 0000019E 81E300000F00                and ebx,0x000f0000
   362 000001A4 09DA                        or  edx,ebx     ;Set Limit 19:16
   363                                  
   364 000001A6 09CA                        or  edx,ecx     ;Set Prop.
   365                                  
   366 000001A8 5B                          pop ebx
   367                                  
   368 000001A9 C3                          ret
   369                                  
   370 000001AA 0000                    pgdt    dw  0               ;GDT的界限
   371 000001AC 007E0000                        dd  0x7e00          ;GDT的物理地址
   372                                  
   373 000001B0 00<rept>                times 510-($-$$)    db 0
   374 000001FE 55AA                                        db 0x55,0xaa
   375                                  
   376                                  ; vim: set syntax=nasm:
